================================================================================
tideWise 자동매매 알고리즘 개발 가이드
================================================================================

[가이드 목적]
이 가이드는 tideWise 시스템과 완벽하게 호환되는 자동매매 알고리즘을 개발하기 위한 종합적이고 명확한 지침을 제공합니다.

[대상 알고리즘]
- 장기간 보유 전략 (수일 ~ 수주)
- 테마주 분석 기반 자동매매
- 기술적 분석 기반 매매 신호 생성
- 리스크 관리 및 포지션 사이징

================================================================================
1. 파일 구조 및 명명 규칙
================================================================================

[1.1] 파일 위치
- 저장 경로: C:\Distribute_tideWise\Algorithm\
- 지원 확장자: .py, .pine, .js, .txt, .json

[1.2] 파일 명명 규칙
- Python 파일: [전략명]_Trading.py (예: Enhanced_DavidPaul_Trading.py)
- 설명 파일: [전략명]_Trading.md (선택사항)
- 버전 관리: [전략명]_v1.0.py 형태로 버전 표기

[1.3] 폴더 내 필수 구조
Algorithm/
├── [알고리즘명].py          # 메인 알고리즘 파일
├── [알고리즘명].md          # 설명 문서 (선택)
└── README.md                # 알고리즘 개요 (권장)

================================================================================
2. Python 알고리즘 필수 구조
================================================================================

[2.1] 기본 클래스 상속
```python
from support.algorithm_interface import BaseAlgorithm

class YourAlgorithm(BaseAlgorithm):
    def __init__(self):
        super().__init__()
        self.algorithm_name = "Your_Algorithm_Name"
        self.description = "알고리즘 설명"
        self.version = "1.0"
```

[2.2] 필수 구현 메서드
```python
def analyze(self, stock_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    매매 신호 분석 (필수 구현)
    
    Args:
        stock_data: {
            'current_price': float,      # 현재가
            'open_price': float,         # 시가
            'high_price': float,         # 고가
            'low_price': float,          # 저가
            'volume': int,               # 거래량
            'change_rate': float,        # 등락률 (-1.0 ~ 1.0)
            'volume_ratio': float,       # 거래량 비율
            'market_cap': float,         # 시가총액
            'ohlcv_data': pd.DataFrame   # OHLCV 데이터 (사용 가능시)
        }
    
    Returns:
        {
            'signal': str,               # 'BUY', 'SELL', 'HOLD' 중 하나
            'confidence': float,         # 신뢰도 (0.0 ~ 1.0)
            'reason': str,              # 매매 근거 설명
            'target_price': float,      # 목표가 (선택사항)
            'stop_loss': float,         # 손절가 (선택사항)
            'position_size': float      # 포지션 크기 비율 (0.0 ~ 1.0)
        }
    """
    # 알고리즘 로직 구현
    return result
```

[2.3] 권장 구현 메서드
```python
def get_name(self) -> str:
    """알고리즘 이름 반환"""
    return self.algorithm_name

def get_version(self) -> str:
    """알고리즘 버전 반환"""
    return self.version

def get_description(self) -> str:
    """알고리즘 설명 반환"""
    return self.description

def calculate_position_size(self, price: float, cash: float) -> int:
    """포지션 크기 계산"""
    return max(1, int(cash * self.position_size_ratio / price))
```

================================================================================
3. 입력 데이터 형식 및 처리
================================================================================

[3.1] 기본 주가 데이터
- current_price: 현재가 (float)
- open_price: 시가 (float)  
- high_price: 고가 (float)
- low_price: 저가 (float)
- volume: 거래량 (int)
- change_rate: 등락률 (-1.0 ~ 1.0 범위)

[3.2] 확장 데이터
- volume_ratio: 평균 거래량 대비 비율
- market_cap: 시가총액
- ohlcv_data: pandas DataFrame (일봉 데이터)
- technical_indicators: 기술적 지표 딕셔너리

[3.3] 데이터 검증 코드
```python
def validate_stock_data(self, stock_data: Dict[str, Any]) -> bool:
    """입력 데이터 유효성 검사"""
    required_fields = ['current_price', 'open_price', 'high_price', 'low_price', 'volume']
    
    for field in required_fields:
        if field not in stock_data:
            logger.warning(f"필수 데이터 누락: {field}")
            return False
        
        value = stock_data[field]
        if value is None or (isinstance(value, float) and np.isnan(value)):
            logger.warning(f"유효하지 않은 데이터: {field} = {value}")
            return False
            
        if field != 'volume' and value <= 0:
            logger.warning(f"가격 데이터가 0 이하: {field} = {value}")
            return False
    
    return True
```

================================================================================
4. 출력 형식 및 신호 생성
================================================================================

[4.1] 표준 출력 형식
```python
{
    'signal': 'BUY' | 'SELL' | 'HOLD',     # 필수: 매매 신호
    'confidence': 0.75,                     # 필수: 신뢰도 (0.0~1.0)
    'reason': '기술적 돌파 + 거래량 급증',    # 필수: 매매 근거
    'target_price': 50000.0,               # 선택: 목표가
    'stop_loss': 45000.0,                  # 선택: 손절가
    'position_size': 0.1,                  # 선택: 포지션 비율
    'risk_level': 'MEDIUM',                # 선택: 리스크 수준
    'indicators': {                        # 선택: 기술적 지표값
        'rsi': 65.2,
        'macd': 0.15,
        'volume_spike': True
    }
}
```

[4.2] 신호 생성 규칙
- BUY: 명확한 매수 신호 + 신뢰도 0.6 이상
- SELL: 명확한 매도 신호 + 신뢰도 0.6 이상  
- HOLD: 불확실하거나 신뢰도 0.6 미만

[4.3] 신뢰도 계산 예시
```python
def calculate_confidence(self, signals: Dict[str, float]) -> float:
    """다중 지표 기반 신뢰도 계산"""
    weights = {
        'trend_score': 0.3,
        'volume_score': 0.25,
        'momentum_score': 0.25,
        'risk_score': 0.2
    }
    
    confidence = sum(signals[key] * weight for key, weight in weights.items())
    return max(0.0, min(1.0, confidence))  # 0~1 범위로 제한
```

================================================================================
5. 기술적 지표 구현 가이드
================================================================================

[5.1] 필수 라이브러리
```python
import pandas as pd
import numpy as np
from typing import Dict, Any, Optional, Tuple
import logging
```

[5.2] 기본 지표 구현 템플릿
```python
def calculate_sma(self, prices: pd.Series, period: int) -> pd.Series:
    """단순이동평균"""
    return prices.rolling(window=period).mean()

def calculate_ema(self, prices: pd.Series, span: int) -> pd.Series:
    """지수이동평균"""
    return prices.ewm(span=span, adjust=False).mean()

def calculate_rsi(self, prices: pd.Series, period: int = 14) -> pd.Series:
    """RSI 계산"""
    delta = prices.diff()
    gain = delta.clip(lower=0).rolling(window=period).mean()
    loss = (-delta.clip(upper=0)).rolling(window=period).mean()
    rs = gain / (loss.replace(0, np.nan))
    return 100 - (100 / (1 + rs))

def calculate_macd(self, prices: pd.Series, fast=12, slow=26, signal=9):
    """MACD 계산"""
    exp1 = prices.ewm(span=fast).mean()
    exp2 = prices.ewm(span=slow).mean()
    macd = exp1 - exp2
    macd_signal = macd.ewm(span=signal).mean()
    return macd, macd_signal, macd - macd_signal
```

[5.3] 볼린저 밴드 구현
```python
def calculate_bollinger_bands(self, prices: pd.Series, period: int = 20, std_dev: float = 2):
    """볼린저 밴드"""
    sma = prices.rolling(window=period).mean()
    std = prices.rolling(window=period).std()
    upper_band = sma + (std * std_dev)
    lower_band = sma - (std * std_dev)
    return upper_band, sma, lower_band
```

================================================================================
6. 리스크 관리 및 포지션 사이징
================================================================================

[6.1] 기본 리스크 관리 파라미터
```python
class RiskManagement:
    def __init__(self):
        self.max_position_size = 0.15      # 최대 포지션 15%
        self.stop_loss_pct = 0.03          # 손절 3%
        self.take_profit_pct = 0.07        # 익절 7%
        self.max_daily_loss = 0.05         # 일일 최대 손실 5%
        self.max_positions = 5             # 최대 동시 포지션 수
```

[6.2] ATR 기반 동적 손절
```python
def calculate_atr_stop_loss(self, high: pd.Series, low: pd.Series, 
                           close: pd.Series, multiplier: float = 2.0) -> float:
    """ATR 기반 손절가 계산"""
    tr = pd.concat([
        (high - low).abs(),
        (high - close.shift(1)).abs(),
        (low - close.shift(1)).abs()
    ], axis=1).max(axis=1)
    
    atr = tr.ewm(span=14).mean().iloc[-1]
    current_price = close.iloc[-1]
    
    return current_price - (atr * multiplier)
```

[6.3] 켈리 공식 기반 포지션 사이징
```python
def kelly_position_size(self, win_rate: float, avg_win: float, avg_loss: float) -> float:
    """켈리 공식으로 최적 포지션 크기 계산"""
    if avg_loss <= 0:
        return 0.0
    
    win_loss_ratio = avg_win / abs(avg_loss)
    kelly_fraction = (win_rate * win_loss_ratio - (1 - win_rate)) / win_loss_ratio
    
    # 켈리 비율의 25%만 사용 (안전 마진)
    return max(0.0, min(0.25, kelly_fraction * 0.25))
```

================================================================================
7. 한국 시장 특화 고려사항
================================================================================

[7.1] VI(Volatility Interruption) 처리
```python
def handle_vi_status(self, vi_status: str, stock_data: Dict[str, Any]) -> Dict[str, Any]:
    """VI 상황 처리"""
    if vi_status in ['상한가', '상승VI']:
        return {
            'signal': 'HOLD',
            'confidence': 0.9,
            'reason': '상승 VI 발생 - 관망'
        }
    elif vi_status in ['하한가', '하락VI']:
        return {
            'signal': 'SELL',
            'confidence': 0.95,
            'reason': '하락 VI 발생 - 즉시 매도'
        }
    return None  # VI 없음
```

[7.2] 한국 시장 시간대 처리
```python
def is_trading_time(self) -> bool:
    """한국 시장 거래시간 확인"""
    from datetime import datetime, time
    
    now = datetime.now().time()
    market_open = time(9, 0, 0)    # 09:00
    market_close = time(15, 30, 0)  # 15:30
    
    return market_open <= now <= market_close
```

[7.3] 한국 주식 특화 지표
```python
def calculate_foreigner_net_buying(self, stock_data: Dict[str, Any]) -> float:
    """외국인 순매수 비율 계산"""
    foreigner_buy = stock_data.get('foreigner_buy_volume', 0)
    total_volume = stock_data.get('volume', 1)
    
    return foreigner_buy / total_volume if total_volume > 0 else 0.0

def check_theme_sector(self, stock_code: str) -> Optional[str]:
    """테마섹터 확인"""
    # 테마주 분류 로직
    theme_mapping = {
        '005930': 'SEMICONDUCTOR',  # 삼성전자
        '000660': 'SEMICONDUCTOR',  # SK하이닉스
        # ... 추가 매핑
    }
    
    return theme_mapping.get(stock_code, None)
```

================================================================================
8. 로깅 및 오류 처리
================================================================================

[8.1] 로깅 설정
```python
import logging

logger = logging.getLogger(__name__)

class YourAlgorithm(BaseAlgorithm):
    def __init__(self):
        super().__init__()
        # 로깅 레벨 설정
        self.setup_logging()
    
    def setup_logging(self):
        """로깅 설정"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
```

[8.2] 표준 오류 처리
```python
def analyze(self, stock_data: Dict[str, Any]) -> Dict[str, Any]:
    try:
        # 데이터 유효성 검사
        if not self.validate_stock_data(stock_data):
            return self.create_hold_signal("데이터 유효성 검사 실패")
        
        # 알고리즘 로직 실행
        result = self.execute_algorithm_logic(stock_data)
        
        # 결과 유효성 검사
        if not self.validate_result(result):
            return self.create_hold_signal("결과 유효성 검사 실패")
            
        logger.info(f"알고리즘 분석 완료: {result['signal']} (신뢰도: {result['confidence']:.2f})")
        return result
        
    except Exception as e:
        logger.error(f"알고리즘 실행 오류: {str(e)}")
        return self.create_error_signal(str(e))

def create_hold_signal(self, reason: str) -> Dict[str, Any]:
    """안전한 HOLD 신호 생성"""
    return {
        'signal': 'HOLD',
        'confidence': 0.0,
        'reason': reason,
        'indicators': {}
    }

def create_error_signal(self, error_msg: str) -> Dict[str, Any]:
    """오류 발생시 안전 신호"""
    return {
        'signal': 'HOLD',
        'confidence': 0.0,
        'reason': f'오류 발생: {error_msg[:50]}...',
        'error': True
    }
```

================================================================================
9. 테스팅 및 검증
================================================================================

[9.1] 단위 테스트 작성
```python
import unittest
import pandas as pd

class TestYourAlgorithm(unittest.TestCase):
    def setUp(self):
        self.algorithm = YourAlgorithm()
        self.sample_data = {
            'current_price': 50000.0,
            'open_price': 48000.0,
            'high_price': 51000.0,
            'low_price': 47000.0,
            'volume': 1000000,
            'change_rate': 0.042,
            'volume_ratio': 1.5
        }
    
    def test_basic_analysis(self):
        """기본 분석 테스트"""
        result = self.algorithm.analyze(self.sample_data)
        
        self.assertIn('signal', result)
        self.assertIn(result['signal'], ['BUY', 'SELL', 'HOLD'])
        self.assertIn('confidence', result)
        self.assertGreaterEqual(result['confidence'], 0.0)
        self.assertLessEqual(result['confidence'], 1.0)
    
    def test_invalid_data(self):
        """잘못된 데이터 처리 테스트"""
        invalid_data = self.sample_data.copy()
        invalid_data['current_price'] = -100  # 음수 가격
        
        result = self.algorithm.analyze(invalid_data)
        self.assertEqual(result['signal'], 'HOLD')
```

[9.2] 백테스팅 검증
```python
def backtest_validation(self, historical_data: pd.DataFrame) -> Dict[str, float]:
    """간단한 백테스팅 검증"""
    signals = []
    returns = []
    
    for i in range(len(historical_data) - 1):
        current_data = {
            'current_price': historical_data.iloc[i]['close'],
            'open_price': historical_data.iloc[i]['open'],
            'high_price': historical_data.iloc[i]['high'],
            'low_price': historical_data.iloc[i]['low'],
            'volume': historical_data.iloc[i]['volume'],
            'change_rate': (historical_data.iloc[i]['close'] - 
                          historical_data.iloc[i]['open']) / historical_data.iloc[i]['open']
        }
        
        result = self.analyze(current_data)
        signals.append(result['signal'])
        
        # 수익률 계산 (다음 날 종가 기준)
        if result['signal'] == 'BUY':
            next_return = (historical_data.iloc[i+1]['close'] - 
                          historical_data.iloc[i]['close']) / historical_data.iloc[i]['close']
            returns.append(next_return)
    
    return {
        'total_signals': len([s for s in signals if s != 'HOLD']),
        'buy_accuracy': self.calculate_accuracy(signals, returns, 'BUY'),
        'average_return': np.mean(returns) if returns else 0.0
    }
```

================================================================================
10. 배포 및 통합 가이드
================================================================================

[10.1] 알고리즘 등록 절차
1. Algorithm 폴더에 .py 파일 저장
2. tideWise 실행 후 "알고리즘 선택" 메뉴에서 확인
3. 디버그 모드에서 기능 테스트 수행
4. 모의투자로 실제 성능 검증

[10.2] 성능 모니터링
```python
class PerformanceTracker:
    def __init__(self):
        self.trades = []
        self.performance_metrics = {}
    
    def record_trade(self, entry_price: float, exit_price: float, 
                    signal_confidence: float):
        """거래 기록"""
        trade = {
            'entry_price': entry_price,
            'exit_price': exit_price,
            'return': (exit_price - entry_price) / entry_price,
            'confidence': signal_confidence,
            'timestamp': datetime.now()
        }
        self.trades.append(trade)
    
    def calculate_metrics(self) -> Dict[str, float]:
        """성능 지표 계산"""
        if not self.trades:
            return {}
        
        returns = [trade['return'] for trade in self.trades]
        win_trades = [r for r in returns if r > 0]
        
        return {
            'total_return': sum(returns),
            'win_rate': len(win_trades) / len(returns),
            'average_return': np.mean(returns),
            'sharpe_ratio': np.mean(returns) / np.std(returns) if np.std(returns) > 0 else 0,
            'max_drawdown': self.calculate_max_drawdown(returns)
        }
```

[10.3] 버전 관리
- 알고리즘 수정시 version 번호 증가
- 주요 변경사항은 docstring에 기록
- 이전 버전과의 호환성 유지

================================================================================
11. 일반적인 실수 및 해결방법
================================================================================

[11.1] 자주 발생하는 오류
✗ 잘못된 예: return "BUY"  # 문자열 반환
✓ 올바른 예: return {'signal': 'BUY', 'confidence': 0.8, 'reason': '매수 신호'}

✗ 잘못된 예: confidence = 1.5  # 범위 초과
✓ 올바른 예: confidence = max(0.0, min(1.0, raw_confidence))

✗ 잘못된 예: price = stock_data['current_price']  # KeyError 가능성
✓ 올바른 예: price = stock_data.get('current_price', 0)

[11.2] 성능 최적화 팁
- pandas 연산을 벡터화하여 속도 향상
- 불필요한 계산은 캐싱 활용
- 메모리 사용량 모니터링
- 복잡한 지표는 필요시에만 계산

[11.3] 디버깅 가이드
```python
def debug_analysis(self, stock_data: Dict[str, Any]) -> None:
    """디버깅용 상세 출력"""
    logger.debug(f"입력 데이터: {stock_data}")
    
    # 중간 계산값 출력
    indicators = self.calculate_indicators(stock_data)
    logger.debug(f"기술적 지표: {indicators}")
    
    # 신호 생성 과정 출력
    signal_components = self.analyze_signal_components(stock_data, indicators)
    logger.debug(f"신호 구성요소: {signal_components}")
```

================================================================================
12. 예제 알고리즘 템플릿
================================================================================

```python
"""
Example Trading Algorithm
기본 이동평균 크로스오버 전략 예제
"""

import pandas as pd
import numpy as np
from typing import Dict, Any
import logging
from support.algorithm_interface import BaseAlgorithm

logger = logging.getLogger(__name__)

class ExampleTradingAlgorithm(BaseAlgorithm):
    def __init__(self):
        super().__init__()
        self.algorithm_name = "Example_Trading"
        self.description = "이동평균 크로스오버 + RSI 필터"
        self.version = "1.0"
        
        # 파라미터 설정
        self.sma_short = 5
        self.sma_long = 20
        self.rsi_period = 14
        self.rsi_oversold = 30
        self.rsi_overbought = 70
        
        # 내부 상태
        self.price_history = []
    
    def analyze(self, stock_data: Dict[str, Any]) -> Dict[str, Any]:
        try:
            # 데이터 검증
            if not self.validate_stock_data(stock_data):
                return self.create_hold_signal("데이터 검증 실패")
            
            current_price = stock_data['current_price']
            self.price_history.append(current_price)
            
            # 충분한 데이터가 없으면 HOLD
            if len(self.price_history) < self.sma_long:
                return self.create_hold_signal("데이터 부족")
            
            # 최근 데이터만 유지 (메모리 효율성)
            if len(self.price_history) > 100:
                self.price_history = self.price_history[-100:]
            
            # 기술적 지표 계산
            prices = pd.Series(self.price_history)
            sma_short = prices.rolling(self.sma_short).mean().iloc[-1]
            sma_long = prices.rolling(self.sma_long).mean().iloc[-1]
            rsi = self.calculate_rsi(prices).iloc[-1]
            
            # 신호 생성
            signal = 'HOLD'
            confidence = 0.5
            reason = "중립"
            
            # 골든 크로스 + RSI 과매도
            if sma_short > sma_long and rsi < self.rsi_oversold:
                signal = 'BUY'
                confidence = 0.8
                reason = f"골든크로스 + RSI과매도({rsi:.1f})"
            
            # 데드 크로스 + RSI 과매수
            elif sma_short < sma_long and rsi > self.rsi_overbought:
                signal = 'SELL'
                confidence = 0.75
                reason = f"데드크로스 + RSI과매수({rsi:.1f})"
            
            return {
                'signal': signal,
                'confidence': confidence,
                'reason': reason,
                'indicators': {
                    'sma_short': sma_short,
                    'sma_long': sma_long,
                    'rsi': rsi
                }
            }
            
        except Exception as e:
            logger.error(f"알고리즘 오류: {e}")
            return self.create_error_signal(str(e))
    
    def calculate_rsi(self, prices: pd.Series) -> pd.Series:
        """RSI 계산"""
        delta = prices.diff()
        gain = delta.clip(lower=0).rolling(self.rsi_period).mean()
        loss = (-delta.clip(upper=0)).rolling(self.rsi_period).mean()
        rs = gain / (loss.replace(0, np.nan))
        return 100 - (100 / (1 + rs))
    
    def validate_stock_data(self, stock_data: Dict[str, Any]) -> bool:
        """데이터 유효성 검사"""
        required_fields = ['current_price', 'volume']
        return all(field in stock_data and stock_data[field] > 0 
                  for field in required_fields)
    
    def create_hold_signal(self, reason: str) -> Dict[str, Any]:
        return {
            'signal': 'HOLD',
            'confidence': 0.0,
            'reason': reason,
            'indicators': {}
        }
    
    def create_error_signal(self, error: str) -> Dict[str, Any]:
        return {
            'signal': 'HOLD',
            'confidence': 0.0,
            'reason': f'오류: {error}',
            'error': True
        }

# 알고리즘 인스턴스 생성 (tideWise가 자동으로 감지)
algorithm_instance = ExampleTradingAlgorithm()
```

================================================================================
체크리스트 - 배포 전 확인사항
================================================================================

□ BaseAlgorithm 클래스 상속
□ analyze() 메서드 필수 구현  
□ 올바른 반환 형식 (Dict with signal, confidence, reason)
□ 데이터 유효성 검사 로직 포함
□ 예외 처리 및 오류 신호 구현
□ 로깅 설정 및 디버깅 코드 포함
□ 단위 테스트 작성 및 통과
□ 알고리즘 메타데이터 설정 (name, version, description)
□ 한국 시장 특화 고려사항 반영
□ 성능 최적화 및 메모리 관리

================================================================================
연락처 및 지원
================================================================================

- 알고리즘 개발 관련 문의: tideWise 개발팀
- 기술 지원: 시스템 로그 및 디버그 모드 활용
- 업데이트: 정기적인 가이드라인 확인 권장

이 가이드를 따라 개발된 알고리즘은 tideWise 시스템과 완벽하게 호환되며,
안정적이고 효율적인 자동매매를 지원합니다.

================================================================================
문서 버전: 1.0
최종 수정일: 2025-01-22
다음 업데이트 예정: 2025-04-22
================================================================================